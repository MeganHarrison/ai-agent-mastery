name: Docker Container Builds

on:
  workflow_call:
  push:
    branches: [ main, module-6-prep ]
  pull_request:
    branches: [ main, module-6-prep ]
  workflow_dispatch:

env:
  # Mock environment variables for Docker builds
  LLM_PROVIDER: openai
  LLM_BASE_URL: https://api.openai.com/v1
  LLM_API_KEY: mock-api-key-for-testing
  LLM_CHOICE: gpt-4o-mini
  VISION_LLM_CHOICE: gpt-4o-mini
  EMBEDDING_PROVIDER: openai
  EMBEDDING_BASE_URL: https://api.openai.com/v1
  EMBEDDING_API_KEY: mock-embedding-key-for-testing
  EMBEDDING_MODEL_CHOICE: text-embedding-3-small
  DATABASE_URL: postgresql://mock:mock@localhost:5432/mock
  SUPABASE_URL: https://mock-project.supabase.co
  SUPABASE_SERVICE_KEY: mock-service-key-for-testing
  SUPABASE_ANON_KEY: mock-anon-key-for-testing
  BRAVE_API_KEY: mock-brave-key-for-testing
  SEARXNG_BASE_URL: http://localhost:8080
  ENVIRONMENT: development
  RAG_PIPELINE_TYPE: local
  RUN_MODE: continuous
  VITE_SUPABASE_URL: https://mock-project.supabase.co
  VITE_SUPABASE_ANON_KEY: mock-anon-key-for-testing
  VITE_AGENT_ENDPOINT: http://localhost:8001/api/pydantic-agent
  VITE_ENABLE_STREAMING: true

jobs:
  docker-compose-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Create test environment file
      run: |
        cd 6_Agent_Deployment
        cat > .env << EOF
        # Mock environment variables for CI testing
        LLM_PROVIDER=${{ env.LLM_PROVIDER }}
        LLM_BASE_URL=${{ env.LLM_BASE_URL }}
        LLM_API_KEY=${{ env.LLM_API_KEY }}
        LLM_CHOICE=${{ env.LLM_CHOICE }}
        VISION_LLM_CHOICE=${{ env.VISION_LLM_CHOICE }}
        EMBEDDING_PROVIDER=${{ env.EMBEDDING_PROVIDER }}
        EMBEDDING_BASE_URL=${{ env.EMBEDDING_BASE_URL }}
        EMBEDDING_API_KEY=${{ env.EMBEDDING_API_KEY }}
        EMBEDDING_MODEL_CHOICE=${{ env.EMBEDDING_MODEL_CHOICE }}
        DATABASE_URL=${{ env.DATABASE_URL }}
        SUPABASE_URL=${{ env.SUPABASE_URL }}
        SUPABASE_SERVICE_KEY=${{ env.SUPABASE_SERVICE_KEY }}
        SUPABASE_ANON_KEY=${{ env.SUPABASE_ANON_KEY }}
        BRAVE_API_KEY=${{ env.BRAVE_API_KEY }}
        SEARXNG_BASE_URL=${{ env.SEARXNG_BASE_URL }}
        ENVIRONMENT=${{ env.ENVIRONMENT }}
        RAG_PIPELINE_TYPE=${{ env.RAG_PIPELINE_TYPE }}
        RUN_MODE=single
        RAG_PIPELINE_ID=ci-test-pipeline
        RAG_WATCH_DIRECTORY=/app/Local_Files/data
        GOOGLE_DRIVE_CREDENTIALS_JSON=
        RAG_WATCH_FOLDER_ID=
        CHECK_INTERVAL=30
        VITE_SUPABASE_URL=${{ env.VITE_SUPABASE_URL }}
        VITE_SUPABASE_ANON_KEY=${{ env.VITE_SUPABASE_ANON_KEY }}
        VITE_AGENT_ENDPOINT=${{ env.VITE_AGENT_ENDPOINT }}
        VITE_ENABLE_STREAMING=${{ env.VITE_ENABLE_STREAMING }}
        EOF
        
    - name: Build all containers with Docker Compose
      run: |
        cd 6_Agent_Deployment
        docker compose build --no-cache
        
    - name: Test Docker Compose stack startup
      run: |
        cd 6_Agent_Deployment
        
        # Start services in background
        echo "Starting Docker Compose stack..."
        docker compose up -d
        
        # Wait for services to initialize
        echo "Waiting for services to start..."
        sleep 45
        
        # Check service status and ensure they're running
        echo "Checking service status..."
        docker compose ps
        
        # Get container status and fail if any are not healthy/running
        FRONTEND_STATUS=$(docker compose ps frontend --format "{{.State}}")
        echo "Frontend status: $FRONTEND_STATUS"
        
        # Frontend should be running
        if [[ "$FRONTEND_STATUS" != "running" ]]; then
          echo "❌ Frontend container is not running!"
          docker compose logs frontend
          exit 1
        fi
        
        # Test frontend accessibility (must succeed)
        echo "Testing frontend accessibility..."
        if ! curl -f http://localhost:8082 -o /dev/null -s --max-time 10; then
          echo "❌ Frontend is not accessible on port 8082!"
          docker compose logs frontend
          exit 1
        fi
        echo "✅ Frontend is accessible"
        
        # Check for container restart loops (indicates startup failures)
        AGENT_RESTARTS=$(docker inspect dynamous-agent-api --format='{{.RestartCount}}')
        RAG_RESTARTS=$(docker inspect dynamous-rag-pipeline --format='{{.RestartCount}}')
        
        echo "Agent API restart count: $AGENT_RESTARTS"
        echo "RAG Pipeline restart count: $RAG_RESTARTS"
        
        # Allow a few restarts for initialization, but fail if too many
        if [ "$AGENT_RESTARTS" -gt 5 ]; then
          echo "❌ Agent API container is restart looping (${AGENT_RESTARTS} restarts)!"
          docker compose logs agent-api
          exit 1
        fi
        
        if [ "$RAG_RESTARTS" -gt 5 ]; then
          echo "❌ RAG Pipeline container is restart looping (${RAG_RESTARTS} restarts)!"
          docker compose logs rag-pipeline  
          exit 1
        fi
        
        # Check for critical startup errors in logs
        echo "Checking for critical startup errors..."
        if docker compose logs | grep -i "application startup failed\|critical\|fatal.*error" | grep -v "expected"; then
          echo "❌ Critical errors found in container logs!"
          docker compose logs
          exit 1
        fi
        
        echo "✅ All containers started successfully"
        
    - name: Test RAG Pipeline single run mode
      run: |
        cd 6_Agent_Deployment
        
        # Test RAG pipeline in single run mode
        echo "Testing RAG Pipeline single run mode..."
        
        # Run pipeline in single mode and capture exit code
        set +e  # Don't exit on command failure
        docker compose run --rm rag-pipeline
        RAG_EXIT_CODE=$?
        set -e  # Re-enable exit on failure
        
        echo "RAG Pipeline exit code: $RAG_EXIT_CODE"
        
        # Exit codes 0-1 are acceptable (success or retry needed)
        # Exit codes 2-3 indicate configuration/auth errors (should fail)
        if [ "$RAG_EXIT_CODE" -eq 0 ]; then
          echo "✅ RAG Pipeline completed successfully"
        elif [ "$RAG_EXIT_CODE" -eq 1 ]; then
          echo "✅ RAG Pipeline completed (retry status - acceptable for CI)"
        else
          echo "❌ RAG Pipeline failed with exit code $RAG_EXIT_CODE"
          # Show logs for debugging
          docker compose logs rag-pipeline
          exit 1
        fi
        
    - name: Cleanup
      if: always()
      run: |
        cd 6_Agent_Deployment
        docker compose down -v
        docker system prune -f